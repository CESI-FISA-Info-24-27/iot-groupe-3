

name: CD Frontend - Déploiement automatique

# Déclenchement après succès du CI OU manuellement
on:
  workflow_run:
    workflows: ["CI EcoGuard IoT"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    branches:
      - main
  workflow_dispatch:

jobs:
  # ========================================
  # Job : Vérification que tests frontend OK
  # Job : Vérification que tests frontend OK
  # ========================================
  check-frontend-tests:
    name: Check Frontend Tests Status
  check-frontend-tests:
    name: Check Frontend Tests Status
    runs-on: ubuntu-latest
    # Condition stricte : CI doit être terminé (succès ou échec)
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion != 'cancelled' }}
    # Condition stricte : CI doit être terminé (succès ou échec)
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion != 'cancelled' }}
    outputs:
      can-deploy: ${{ steps.check.outputs.can-deploy }}
      can-deploy: ${{ steps.check.outputs.can-deploy }}
    steps:
      - name: Check if frontend tests passed
        id: check
        uses: actions/github-script@v7
      - name: Check if frontend tests passed
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            let ciRunId, ciConclusion;
            
            if (context.eventName === 'workflow_dispatch') {
              // Pour déclenchement manuel : chercher le dernier CI
              const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci.yml',
                branch: 'main',
                per_page: 1
              });
              
              if (workflows.workflow_runs.length === 0) {
                console.log('No CI workflow found for main branch');
                core.setOutput('can-deploy', 'true'); // Permettre déploiement manuel sans CI
                return;
              }
              
              ciRunId = workflows.workflow_runs[0].id;
              ciConclusion = workflows.workflow_runs[0].conclusion;
            } else {
              // Pour workflow_run : utiliser le workflow qui vient de se terminer
              ciRunId = context.payload.workflow_run.id;
              ciConclusion = context.payload.workflow_run.conclusion;
            }
            
            console.log(`CI Run ID: ${ciRunId}, Conclusion: ${ciConclusion}`);
            
            // Récupérer les jobs du workflow CI
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ciRunId
            });
            
            // Chercher le job "Frontend Unit Tests"
            const frontendJob = jobs.jobs.find(job => job.name === 'Frontend Unit Tests');
            
            if (!frontendJob) {
              console.log('Frontend Unit Tests job not found');
              core.setOutput('can-deploy', 'false');
              return;
            }
            
            // Déployer SEULEMENT si les tests frontend ont explicitement réussi
            // (pas de déploiement si continue-on-error a masqué un échec)
            const canDeploy = frontendJob.conclusion === 'success';
            
            console.log(`Frontend tests status: ${frontendJob.conclusion}`);
            console.log(`Can deploy: ${canDeploy}`);
            
            core.setOutput('can-deploy', canDeploy.toString());
          script: |
            let ciRunId, ciConclusion;
            
            if (context.eventName === 'workflow_dispatch') {
              // Pour déclenchement manuel : chercher le dernier CI
              const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci.yml',
                branch: 'main',
                per_page: 1
              });
              
              if (workflows.workflow_runs.length === 0) {
                console.log('No CI workflow found for main branch');
                core.setOutput('can-deploy', 'true'); // Permettre déploiement manuel sans CI
                return;
              }
              
              ciRunId = workflows.workflow_runs[0].id;
              ciConclusion = workflows.workflow_runs[0].conclusion;
            } else {
              // Pour workflow_run : utiliser le workflow qui vient de se terminer
              ciRunId = context.payload.workflow_run.id;
              ciConclusion = context.payload.workflow_run.conclusion;
            }
            
            console.log(`CI Run ID: ${ciRunId}, Conclusion: ${ciConclusion}`);
            
            // Récupérer les jobs du workflow CI
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ciRunId
            });
            
            // Chercher le job "Frontend Unit Tests"
            const frontendJob = jobs.jobs.find(job => job.name === 'Frontend Unit Tests');
            
            if (!frontendJob) {
              console.log('Frontend Unit Tests job not found');
              core.setOutput('can-deploy', 'false');
              return;
            }
            
            // Déployer SEULEMENT si les tests frontend ont explicitement réussi
            // (pas de déploiement si continue-on-error a masqué un échec)
            const canDeploy = frontendJob.conclusion === 'success';
            
            console.log(`Frontend tests status: ${frontendJob.conclusion}`);
            console.log(`Can deploy: ${canDeploy}`);
            
            core.setOutput('can-deploy', canDeploy.toString());

  # ========================================
  # Job : Déploiement sur le serveur
  # ========================================

  deploy:
    name: Deploy Frontend to Server
    runs-on: ubuntu-latest
    needs: [check-frontend-tests]
    if: ${{ github.event_name == 'workflow_dispatch' || needs.check-frontend-tests.outputs.can-deploy == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Préparer le dossier de déploiement
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            # Créer le dossier de déploiement s'il n'existe pas
            mkdir -p ~/ecoguard
            cd ~/ecoguard

            # Nettoyer les anciens fichiers frontend
            rm -rf frontend

      - name: Copier les fichiers sur le serveur
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          source: "frontend/*,docker-compose.yml"
          target: "~/ecoguard"
          overwrite: true

      - name: Build et déployer sur le serveur
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            cd ~/ecoguard

            # Créer le réseau Docker s'il n'existe pas
            docker network create ecoguard-network || true

            # Arrêter et supprimer l'ancien conteneur
            docker stop ecoguard-frontend 2>/dev/null || true
            docker rm ecoguard-frontend 2>/dev/null || true

            # Builder la nouvelle image en mode production (Angular build prod par défaut)
            # Builder la nouvelle image en mode production (Angular build prod par défaut)
            docker build -t ecoguard-frontend:latest ./frontend

            # Démarrer le nouveau conteneur
            docker run -d \
              --name ecoguard-frontend \
              --restart unless-stopped \
              --security-opt apparmor=unconfined \
              -p 8082:80 \
              --network ecoguard-network \
              ecoguard-frontend:latest

            # Nettoyer les images non utilisées
            docker image prune -f

      - name: Vérifier le déploiement
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            cd ~/ecoguard

            # Vérifier que le conteneur tourne
            docker ps | grep ecoguard-frontend

            # Afficher les logs récents
            docker logs --tail 20 ecoguard-frontend

      - name: Notification de succès
        if: success()
        run: echo "Déploiement du frontend réussi sur ${{ secrets.SSH_HOST }}"

      - name: Notification d'échec
        if: failure()
        run: echo "Échec du déploiement du frontend"
